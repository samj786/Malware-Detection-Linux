#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include <unistd.h>
#include <sys/proc_info.h>
#include <mach/mach.h>
#include <libproc.h>
#include <openssl/sha.h>

#define MAX_PROC 1024

// Process state constants for better readability
const char* process_state(int state) {
    switch (state) {
        case SIDL: return "Idle";
        case SRUN: return "Running";
        case SSLEEP: return "Sleeping";
        case SSTOP: return "Stopped";
        default: return "Unknown";
    }
}

// Function to compute SHA-256 hash of a file
void compute_sha256(const char *file_path, unsigned char *output_hash) {
    FILE *file = fopen(file_path, "rb");
    if (!file) {
        perror("Unable to open file for SHA-256 computation");
        return;
    }

    SHA256_CTX sha256_ctx;
    SHA256_Init(&sha256_ctx);

    unsigned char buffer[1024];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        SHA256_Update(&sha256_ctx, buffer, bytes_read);
    }

    SHA256_Final(output_hash, &sha256_ctx);
    fclose(file);
}

// Function to convert SHA-256 hash to a readable hex string
void hash_to_hex_string(unsigned char *hash, char *output_string) {
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(output_string + (i * 2), "%02x", hash[i]);
    }
    output_string[SHA256_DIGEST_LENGTH * 2] = '\0';  // Null-terminate the string
}

int main() {
    int mib[4];
    size_t len;
    struct kinfo_proc *procs;
    int count;

    // Initialize mib array for sysctl to fetch process information
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_ALL;
    mib[3] = 0;

    // Fetch the process information
    sysctl(mib, 4, NULL, &len, NULL, 0);
    procs = (struct kinfo_proc*)malloc(len);
    sysctl(mib, 4, procs, &len, NULL, 0);

    // Calculate the number of processes
    count = len / sizeof(struct kinfo_proc);

    // Open a file to write the CSV data
    FILE *file = fopen("process_info_with_hash.csv", "w");
    if (file == NULL) {
        perror("Failed to open file");
        free(procs);
        return 1;
    }

    // Write the header row for the CSV file
    fprintf(file, "PID,Process Name,State,CPU Time (user+system),RSS Size,SHA-256 Hash\n");

    for (int i = 0; i < count; i++) {
        pid_t pid = procs[i].kp_proc.p_pid;
        char name[256];
        strncpy(name, procs[i].kp_proc.p_comm, sizeof(name));

        // Fetch task info using proc_pidinfo for CPU and memory usage
        struct proc_taskinfo pti;
        size_t pti_len = sizeof(pti);
        if (proc_pidinfo(pid, PROC_PIDTASKINFO, 0, &pti, pti_len) != -1) {
            // Fetch CPU time and memory usage
            unsigned long long total_cpu_time = pti.pti_total_user + pti.pti_total_system;
            unsigned long long rss_size = pti.pti_resident_size;

            // Fetch the process state
            int state = procs[i].kp_proc.p_stat;

            // Get the path of the executable
            char exe_path[1024];
            ssize_t path_len = proc_pidpath(pid, exe_path, sizeof(exe_path));

            // If path is found, compute SHA-256 hash
            char sha256_hash_str[SHA256_DIGEST_LENGTH * 2 + 1]; // To store the hex string
            if (path_len > 0) {
                unsigned char sha256_hash[SHA256_DIGEST_LENGTH];
                compute_sha256(exe_path, sha256_hash);
                hash_to_hex_string(sha256_hash, sha256_hash_str);
            } else {
                strcpy(sha256_hash_str, "N/A");  // If path is not found
            }

            // Write the process information to the CSV file
            fprintf(file, "%d,%s,%s,%llu,%llu,%s\n", 
                    pid, 
                    name, 
                    process_state(state), 
                    total_cpu_time, 
                    rss_size, 
                    sha256_hash_str);
        }
    }

    // Close the file
    fclose(file);

    // Free allocated memory
    free(procs);

    printf("Process information with SHA-256 hash has been written to process_info_with_hash.csv\n");
    return 0;
}
