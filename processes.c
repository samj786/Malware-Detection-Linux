#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include <unistd.h>
#include <sys/proc_info.h>
#include <mach/mach.h>
#include <libproc.h>
#include <openssl/sha.h>

#define MAX_PROC 1024

// Process state constants for better readability
const char *process_state(int state)
{
    switch (state)
    {
    case SIDL:
        return "Idle";
    case SRUN:
        return "Running";
    case SSLEEP:
        return "Sleeping";
    case SSTOP:
        return "Stopped";
    default:
        return "Unknown";
    }
}

// Function to compute SHA-256 hash of a file
void compute_sha256(const char *file_path, unsigned char *output_hash)
{
    FILE *file = fopen(file_path, "rb");
    if (!file)
    {
        perror("Unable to open file for SHA-256 computation");
        return;
    }

    SHA256_CTX sha256_ctx;
    SHA256_Init(&sha256_ctx);

    unsigned char buffer[1024];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0)
    {
        SHA256_Update(&sha256_ctx, buffer, bytes_read);
    }

    SHA256_Final(output_hash, &sha256_ctx);
    fclose(file);
}

#include <stdio.h>
#include <string.h>

void compute_fuzzy_hash(const char *file_path, char *output_hash) {
    char command[1024];
    snprintf(command, sizeof(command), "ssdeep \"%s\"", file_path);
    FILE *fp = popen(command, "r");
    if (fp == NULL) {
        perror("Failed to run ssdeep command");
        strcpy(output_hash, "N/A");
        return;
    }

    // Skip the first line, which is the header
    char line[1024];
    if (fgets(line, sizeof(line), fp) == NULL) {
        strcpy(output_hash, "N/A");
        pclose(fp);
        return;
    }

    // Read the next line, which should contain the fuzzy hash data
    if (fgets(line, sizeof(line), fp) != NULL) {
        // Tokenize the line and retrieve the fuzzy hash (first column)
        char *token = strtok(line, ",");   // First column (fuzzy hash)

        if (token != NULL) {
            strncpy(output_hash, token, 1024);  // Copy the hash to output
            output_hash[1023] = '\0';           // Ensure null-termination
        } else {
            strcpy(output_hash, "N/A");         // Set to "N/A" if no hash found
        }
    } else {
        strcpy(output_hash, "N/A");
    }
    pclose(fp);
}




// Function to convert SHA-256 hash to a readable hex string
void hash_to_hex_string(unsigned char *hash, char *output_string)
{
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++)
    {
        sprintf(output_string + (i * 2), "%02x", hash[i]);
    }
    output_string[SHA256_DIGEST_LENGTH * 2] = '\0'; // Null-terminate the string
}

int main()
{
    int mib[4];
    size_t len;
    struct kinfo_proc *procs;
    int count;

    // Initialize mib array for sysctl to fetch process information
    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_ALL;
    mib[3] = 0;

    // Fetch the process information
    sysctl(mib, 4, NULL, &len, NULL, 0);
    procs = (struct kinfo_proc *)malloc(len);
    sysctl(mib, 4, procs, &len, NULL, 0);

    // Calculate the number of processes
    count = len / sizeof(struct kinfo_proc);

    // Open a file to write the CSV data
    FILE *file = fopen("process_info_with_hash.csv", "w");
    if (file == NULL)
    {
        perror("Failed to open file");
        free(procs);
        return 1;
    }

    // Write the header row for the CSV file
    fprintf(file, "PID,Process Name,State,CPU Time (user+system),RSS Size,SHA-256 Hash,Fuzzy Hash\n");

    for (int i = 0; i < count; i++)
    {
        pid_t pid = procs[i].kp_proc.p_pid;
        char name[256];
        strncpy(name, procs[i].kp_proc.p_comm, sizeof(name));

        // Fetch task info using proc_pidinfo for CPU and memory usage
        struct proc_taskinfo pti;
        size_t pti_len = sizeof(pti);
        if (proc_pidinfo(pid, PROC_PIDTASKINFO, 0, &pti, pti_len) != -1)
        {
            // Fetch CPU time and memory usage
            unsigned long long total_cpu_time = pti.pti_total_user + pti.pti_total_system;
            unsigned long long rss_size = pti.pti_resident_size;

            // Fetch the process state
            int state = procs[i].kp_proc.p_stat;

            // Get the path of the executable
            char exe_path[1024];
            ssize_t path_len = proc_pidpath(pid, exe_path, sizeof(exe_path));

            // If path is found, compute SHA-256 hash
            char sha256_hash_str[SHA256_DIGEST_LENGTH * 2 + 1]; // To store the hex string
            if (path_len > 0)
            {
                unsigned char sha256_hash[SHA256_DIGEST_LENGTH];
                compute_sha256(exe_path, sha256_hash);
                hash_to_hex_string(sha256_hash, sha256_hash_str);
            }
            else
            {
                strcpy(sha256_hash_str, "N/A"); // If path is not found
            }

            char fuzzy_hash[1024];
            if (path_len > 0)
            {
                compute_fuzzy_hash(exe_path, fuzzy_hash);
            }
            else
            {
                strcpy(fuzzy_hash, "N/A");
            }

            // Write the process information to the CSV file, including the fuzzy hash
        fprintf(file, "%d,%s,%s,%llu,%llu,%s,%s\n", 
                pid, 
                name, 
                process_state(state), 
                total_cpu_time, 
                rss_size, 
                sha256_hash_str,
                fuzzy_hash);
        }
    }

    // Close the file
    fclose(file);

    // Free allocated memory
    free(procs);

    printf("Process information with SHA-256 hash has been written to process_info_with_hash.csv\n");
    return 0;
}
