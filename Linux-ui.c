#include <ncurses.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>
#include "processes.c"

#define MAX_COLS 100
#define MAX_ROWS 1000
#define MAX_CELL_SIZE 256

typedef struct {
    char ***data;        // 2D array of strings for CSV data
    int rows;           // Total number of rows
    int cols;           // Total number of columns
    int current_row;    // Current row position for scrolling
    int current_col;    // Current column position for scrolling
    int *col_widths;    // Width of each column
} CSVData;

// Function to split a line into tokens (CSV cells)
char** split_line(char* line, int* count, int* widths) {
    char** tokens = malloc(MAX_COLS * sizeof(char*));
    char* token = strtok(line, ",");
    *count = 0;
    
    while (token != NULL && *count < MAX_COLS) {
        // Remove leading/trailing whitespace and quotes
        while (*token == ' ' || *token == '"') token++;
        int len = strlen(token);
        while (len > 0 && (token[len-1] == ' ' || token[len-1] == '"' || token[len-1] == '\n')) {
            token[--len] = '\0';
        }
        
        tokens[*count] = strdup(token);
        
        // Update column width if this cell is wider
        if (len > widths[*count]) {
            widths[*count] = len;
        }
        
        token = strtok(NULL, ",");
        (*count)++;
    }
    
    return tokens;
}

// Function to load CSV file
CSVData* load_csv(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (!file) {
        return NULL;
    }
    
    CSVData* csv = malloc(sizeof(CSVData));
    csv->data = malloc(MAX_ROWS * sizeof(char**));
    csv->col_widths = calloc(MAX_COLS, sizeof(int));
    csv->rows = 0;
    csv->cols = 0;
    csv->current_row = 0;
    csv->current_col = 0;
    
    char line[MAX_CELL_SIZE * MAX_COLS];
    int line_cols;
    
    while (fgets(line, sizeof(line), file) && csv->rows < MAX_ROWS) {
        csv->data[csv->rows] = split_line(line, &line_cols, csv->col_widths);
        if (csv->cols == 0) csv->cols = line_cols;
        csv->rows++;
    }
    
    fclose(file);
    return csv;
}

// Function to free CSV data
void free_csv(CSVData* csv) {
    for (int i = 0; i < csv->rows; i++) {
        for (int j = 0; j < csv->cols; j++) {
            free(csv->data[i][j]);
        }
        free(csv->data[i]);
    }
    free(csv->data);
    free(csv->col_widths);
    free(csv);
}

// Function to draw the CSV viewer
void draw_csv_viewer(CSVData* csv, WINDOW* win) {
    int max_y, max_x;
    getmaxyx(win, max_y, max_x);
    
    // Clear the window
    werase(win);
    
    // Draw column headers
    wattron(win, A_REVERSE);
    int x_pos = 1;
    for (int j = csv->current_col; j < csv->cols && x_pos < max_x - 2; j++) {
        mvwprintw(win, 1, x_pos, "%-*s", csv->col_widths[j] + 2, csv->data[0][j]);
        x_pos += csv->col_widths[j] + 2;
    }
    wattroff(win, A_REVERSE);
    
    // Draw data rows
    for (int i = 1 + csv->current_row; i < csv->rows && i - csv->current_row < max_y - 3; i++) {
        x_pos = 1;
        for (int j = csv->current_col; j < csv->cols && x_pos < max_x - 2; j++) {
            mvwprintw(win, i - csv->current_row + 2, x_pos, "%-*s", 
                     csv->col_widths[j] + 2, csv->data[i][j]);
            x_pos += csv->col_widths[j] + 2;
        }
    }
    
    // Draw scrollbar if needed
    if (csv->rows > max_y - 3) {
        int scrollbar_pos = (csv->current_row * (max_y - 3)) / csv->rows;
        mvwvline(win, 1, max_x - 1, ACS_VLINE, max_y - 2);
        mvwaddch(win, scrollbar_pos + 1, max_x - 1, ACS_BLOCK);
    }
    
    // Draw status line
    mvwhline(win, max_y - 1, 0, ACS_HLINE, max_x);
    mvwprintw(win, max_y - 1, 1, 
              "Row %d/%d Col %d/%d | Arrow keys to navigate | q to quit", 
              csv->current_row + 1, csv->rows - 1, 
              csv->current_col + 1, csv->cols);
    
    // Draw border
    box(win, 0, 0);
    wrefresh(win);
}

// Global flag to control loading animation
volatile int loading = 0;
WINDOW *main_win;
int loading_row = 0;
char *loading_text = NULL;

// Loading animation thread function
void *loading_animation(void *arg) {
    char loading_chars[] = {'|', '/', '-', '\\'};
    int frame = 0;
    
    while (loading) {
        int text_len = strlen(loading_text);
        int center_pos = (COLS - text_len - 4) / 2;
        
        mvwprintw(main_win, loading_row, center_pos, "%s [%c]", 
                  loading_text, loading_chars[frame % 4]);
        wrefresh(main_win);
        
        frame++;
        usleep(100000);  // 100ms delay
    }
    return NULL;
}

// Function to start loading animation
void start_loading(const char *text, int row) {
    loading_text = strdup(text);
    loading_row = row;
    loading = 1;
    
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, loading_animation, NULL);
    pthread_detach(thread_id);  // Detach thread so it cleans up automatically
}

// Function to stop loading animation
void stop_loading() {
    loading = 0;
    if (loading_text) {
        free(loading_text);
        loading_text = NULL;
    }
    usleep(200000);  // Small delay to ensure thread exits
}

// Function to display menu and get user choice
int display_menu(WINDOW *win) {
    int choice = 0;
    char *menu_items[] = {
        "Scan a file",
        "Scan all processes",
        "Exit"
    };
    int n_items = 3;
    
    while (1) {
        // Clear window
        werase(win);
        box(win, 0, 0);
        
        // Display title
        mvwprintw(win, 2, (COLS-20)/2, "Process Scanner Menu");
        mvwhline(win, 3, 1, ACS_HLINE, COLS-2);
        
        // Display menu items
        for (int i = 0; i < n_items; i++) {
            if (i == choice) {
                wattron(win, A_REVERSE);
            }
            mvwprintw(win, 5 + i*2, (COLS-strlen(menu_items[i]))/2, "%s", menu_items[i]);
            wattroff(win, A_REVERSE);
        }
        
        wrefresh(win);
        
        // Handle input
        int ch = getch();
        switch (ch) {
            case KEY_UP:
                if (choice > 0) choice--;
                break;
            case KEY_DOWN:
                if (choice < n_items - 1) choice++;
                break;
            case 10: // Enter key
                return choice;
        }
    }
}

// Function placeholder for scanning a specific file
void scan_file(WINDOW *win) {
    start_loading("Scan a file", 5);
    
    // Simulate some work (remove this in actual implementation)
    sleep(2);
    
    stop_loading();
    
    // Show "coming soon" message
    mvwprintw(win, LINES/2, (COLS-20)/2, "Feature coming soon!");
    wrefresh(win);
    wgetch(win);
}

// Function to handle viewing CSV data
void view_csv_data(WINDOW *win, const char *filename) {
    // Load CSV file
    CSVData* csv = load_csv(filename);
    if (!csv) {
        stop_loading();
        mvwprintw(win, LINES/2, (COLS-25)/2, "Error loading CSV file!");
        wrefresh(win);
        wgetch(win);
        return;
    }
    
    stop_loading();
    
    // Clear screen before showing CSV data
    werase(win);
    wrefresh(win);
    
    // Main viewing loop
    int ch;
    while ((ch = getch()) != 'q') {
        int max_y, max_x;
        getmaxyx(win, max_y, max_x);
        
        switch (ch) {
            case KEY_UP:
                if (csv->current_row > 0) csv->current_row--;
                break;
            case KEY_DOWN:
                if (csv->current_row < csv->rows - (max_y - 3)) csv->current_row++;
                break;
            case KEY_LEFT:
                if (csv->current_col > 0) csv->current_col--;
                break;
            case KEY_RIGHT:
                if (csv->current_col < csv->cols - 1) csv->current_col++;
                break;
            case KEY_HOME:
                csv->current_row = 0;
                break;
            case KEY_END:
                csv->current_row = csv->rows - (max_y - 3);
                if (csv->current_row < 0) csv->current_row = 0;
                break;
        }
        
        draw_csv_viewer(csv, win);
    }
    
    free_csv(csv);
}

int main() {
    // Initialize ncurses
    initscr();
    raw();
    keypad(stdscr, TRUE);
    noecho();
    curs_set(0);  // Hide cursor
    start_color();
    init_pair(1, COLOR_WHITE, COLOR_BLUE);
    
    // Create main window
    WINDOW *main_win = newwin(LINES, COLS, 0, 0);
    wbkgd(main_win, COLOR_PAIR(1));
    
    int choice;
    do {
        choice = display_menu(main_win);
        
        switch (choice) {
            case 0: // Scan a file
                scan_file(main_win);
                break;
            case 1: // Scan all processes
                start_loading("Scanning all processes", 7);
                start(); // Execute the start() function
                view_csv_data(main_win, "process_info_with_hash.csv");
                break;
            case 2: // Exit
                break;
        }
        
        // Clear the window after returning from any option
        werase(main_win);
        wrefresh(main_win);
        
    } while (choice != 2);
    
    // Clean up
    delwin(main_win);
    endwin();
    return 0;
}