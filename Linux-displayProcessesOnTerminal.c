#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <pwd.h>
#include <openssl/sha.h>
#include <proc/readproc.h>
#include <termios.h>
#include <fcntl.h>

#define MAX_PROC 1024
#define PATH_MAX 4096

// Process state conversion (same as in processes.c)
const char* process_state(char state) {
    switch (state) {
        case 'R': return "Running";
        case 'S': return "Sleeping";
        case 'D': return "Disk Sleep";
        case 'Z': return "Zombie";
        case 'T': return "Stopped";
        case 't': return "Tracing";
        case 'X': return "Dead";
        default: return "Unknown";
    }
}

void compute_sha256(const char *file_path, unsigned char *output_hash) {
    FILE *file = fopen(file_path, "rb");
    if (!file) {
        perror("Unable to open file for SHA-256 computation");
        return;
    }

    SHA256_CTX sha256_ctx;
    SHA256_Init(&sha256_ctx);

    unsigned char buffer[1024];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        SHA256_Update(&sha256_ctx, buffer, bytes_read);
    }

    SHA256_Final(output_hash, &sha256_ctx);
    fclose(file);
}

void hash_to_hex_string(unsigned char *hash, char *output_string) {
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(output_string + (i * 2), "%02x", hash[i]);
    }
    output_string[SHA256_DIGEST_LENGTH * 2] = '\0';
}

int kbhit(void) {
    struct termios oldt, newt;
    int ch;
    int oldf;

    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);

    ch = getchar();

    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    fcntl(STDIN_FILENO, F_SETFL, oldf);

    if (ch != EOF) {
        ungetc(ch, stdin);
        return 1;
    }

    return 0;
}

int main() {
    // Print the header once
    printf("PID\tProcess Name\tState\tCPU Time\tRSS Size\tSHA-256 Hash\n");
    printf("--------------------------------------------------------------------------------\n");

    while (!kbhit()) {
        PROCTAB* proc = openproc(PROC_FILLMEM | PROC_FILLSTAT | PROC_FILLSTATUS);
        if (!proc) continue;

        // Move cursor to the beginning of the process list display area
        printf("\033[2;0H");  // ANSI escape code to move cursor

        proc_t proc_info;
        memset(&proc_info, 0, sizeof(proc_info));

        while (readproc(proc, &proc_info) != NULL) {
            char exe_path[PATH_MAX];
            char sha256_hash_str[SHA256_DIGEST_LENGTH * 2 + 1] = "N/A";

            snprintf(exe_path, sizeof(exe_path), "/proc/%d/exe", proc_info.tid);
            
            if (access(exe_path, R_OK) == 0) {
                char real_path[PATH_MAX];
                if (realpath(exe_path, real_path) != NULL) {
                    unsigned char sha256_hash[SHA256_DIGEST_LENGTH];
                    compute_sha256(real_path, sha256_hash);
                    hash_to_hex_string(sha256_hash, sha256_hash_str);
                }
            }

            printf("%d\t%s\t%s\t%lu\t%lu\t%s\n",
                   proc_info.tid,
                   proc_info.cmd,
                   process_state(proc_info.state),
                   proc_info.utime + proc_info.stime,
                   proc_info.vm_rss,
                   sha256_hash_str);
        }

        closeproc(proc);
        printf("Press Enter to stop...\n");
        usleep(1000000); // Sleep for 1 second
    }

    getchar(); // Consume the Enter key press
    printf("Process information display terminated.\n");
    return 0;
}