#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <pwd.h>
#include <openssl/sha.h>
#include <sys/types.h>
#include <fcntl.h>
#include <ctype.h>

#define MAX_PROC 1024
#define PATH_MAX 4096
#define MAX_LINE 1024

typedef struct {
    int pid;
    char name[256];
    char state;
    unsigned long utime;
    unsigned long stime;
    unsigned long rss;
} ProcessInfo;

// Process state conversion
const char* process_state(char state) {
    switch (state) {
        case 'R': return "Running";
        case 'S': return "Sleeping";
        case 'D': return "Disk Sleep";
        case 'Z': return "Zombie";
        case 'T': return "Stopped";
        case 't': return "Tracing";
        case 'X': return "Dead";
        default: return "Unknown";
    }
}

void compute_sha256(const char *file_path, unsigned char *output_hash) {
    FILE *file = fopen(file_path, "rb");
    if (!file) {
        return;
    }

    SHA256_CTX sha256_ctx;
    SHA256_Init(&sha256_ctx);

    unsigned char buffer[1024];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        SHA256_Update(&sha256_ctx, buffer, bytes_read);
    }

    SHA256_Final(output_hash, &sha256_ctx);
    fclose(file);
}

void hash_to_hex_string(unsigned char *hash, char *output_string) {
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(output_string + (i * 2), "%02x", hash[i]);
    }
    output_string[SHA256_DIGEST_LENGTH * 2] = '\0';
}

void compute_fuzzy_hash(const char *file_path, char *output_hash) {
    char command[1024];
    snprintf(command, sizeof(command), "ssdeep \"%s\"", file_path);
    FILE *fp = popen(command, "r");
    if (fp == NULL) {
        strcpy(output_hash, "N/A");
        return;
    }

    char line[1024];
    if (fgets(line, sizeof(line), fp) == NULL) {
        strcpy(output_hash, "N/A");
        pclose(fp);
        return;
    }

    if (fgets(line, sizeof(line), fp) != NULL) {
        char *token = strtok(line, ",");
        if (token != NULL) {
            strncpy(output_hash, token, 1024);
            output_hash[1023] = '\0';
        } else {
            strcpy(output_hash, "N/A");
        }
    } else {
        strcpy(output_hash, "N/A");
    }
    pclose(fp);
}

ProcessInfo get_process_info(int pid) {
    ProcessInfo info = {0};
    info.pid = pid;
    char path[PATH_MAX];
    char line[MAX_LINE];
    
    // Read process status
    snprintf(path, sizeof(path), "/proc/%d/status", pid);
    FILE *status = fopen(path, "r");
    if (status) {
        while (fgets(line, sizeof(line), status)) {
            if (strncmp(line, "Name:", 5) == 0) {
                sscanf(line, "Name: %255s", info.name);
            } else if (strncmp(line, "State:", 6) == 0) {
                sscanf(line, "State: %c", &info.state);
            }
        }
        fclose(status);
    }
    
    // Read process stat for CPU time
    snprintf(path, sizeof(path), "/proc/%d/stat", pid);
    FILE *stat = fopen(path, "r");
    if (stat) {
        // Skip the first 13 fields
        for (int i = 0; i < 13; i++) {
            fscanf(stat, "%*s");
        }
        fscanf(stat, "%lu %lu", &info.utime, &info.stime);
        fclose(stat);
    }
    
    // Read memory information
    snprintf(path, sizeof(path), "/proc/%d/statm", pid);
    FILE *statm = fopen(path, "r");
    if (statm) {
        fscanf(statm, "%*u %lu", &info.rss);
        info.rss *= getpagesize() / 1024; // Convert to KB
        fclose(statm);
    }
    
    return info;
}

int start() {
    DIR *proc_dir;
    struct dirent *entry;
    FILE *file;

    // Open output file
    file = fopen("process_info_with_hash.csv", "w");
    if (!file) {
        perror("Failed to open output file");
        return 1;
    }

    // Write CSV header
    fprintf(file, "PID,Process Name,State,CPU Time,RSS Size,SHA-256 Hash,Fuzzy Hash\n");

    // Open /proc directory
    proc_dir = opendir("/proc");
    if (!proc_dir) {
        perror("Failed to open /proc");
        fclose(file);
        return 1;
    }

    // Iterate through all entries in /proc
    while ((entry = readdir(proc_dir)) != NULL) {
        // Check if the entry is a PID (all numeric)
        int pid = atoi(entry->d_name);
        if (pid > 0) {
            ProcessInfo proc_info = get_process_info(pid);
            
            char exe_path[PATH_MAX];
            char sha256_hash_str[SHA256_DIGEST_LENGTH * 2 + 1] = "N/A";
            char fuzzy_hash[1024] = "N/A";

            // Get executable path
            snprintf(exe_path, sizeof(exe_path), "/proc/%d/exe", pid);
            
            // Try to read the executable file
            if (access(exe_path, R_OK) == 0) {
                char real_path[PATH_MAX];
                if (realpath(exe_path, real_path) != NULL) {
                    // Compute SHA-256 hash
                    unsigned char sha256_hash[SHA256_DIGEST_LENGTH];
                    compute_sha256(real_path, sha256_hash);
                    hash_to_hex_string(sha256_hash, sha256_hash_str);

                    // Compute fuzzy hash
                    compute_fuzzy_hash(real_path, fuzzy_hash);
                }
            }

            // Write process information to CSV
            fprintf(file, "%d,%s,%s,%lu,%lu,%s,%s\n",
                    proc_info.pid,
                    proc_info.name,
                    process_state(proc_info.state),
                    proc_info.utime + proc_info.stime,
                    proc_info.rss,
                    sha256_hash_str,
                    fuzzy_hash);
        }
    }

    // Clean up
    closedir(proc_dir);
    fclose(file);

    printf("Process information has been written to process_info_with_hash.csv\n");
    return 0;
}