#include "processes.h"
#include <ncurses.h>
#include <string.h>
#include <signal.h>

#define MAIN_WIN_HEIGHT 24
#define MAIN_WIN_WIDTH 80
#define LIST_WIN_HEIGHT (MAIN_WIN_HEIGHT - 8)
#define STATUS_HEIGHT 3

typedef struct {
    WINDOW *main_win;
    WINDOW *list_win;
    WINDOW *status_win;
    WINDOW *header_win;
    int current_index;
    int scroll_position;
    ProcessInfo *all_processes;      // Store all processes
    size_t process_count;            // Total process count
    int *suspicious_indices;         // Store indices of suspicious processes
    int suspicious_count;            // Count of suspicious processes
} UIState;

// Global state
static UIState g_state;
static bool g_running = true;

// Function prototypes
void init_ui(void);
void cleanup_ui(void);
void draw_process_list(UIState *state);
void draw_header(WINDOW *win);
void show_status_message(WINDOW *win, const char *message);

void init_ui(void) {
    // Initialize ncurses
    initscr();
    start_color();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0);
    
    // Initialize color pairs
    init_pair(1, COLOR_WHITE, COLOR_BLUE);    // Header/Footer
    init_pair(2, COLOR_BLACK, COLOR_WHITE);   // Selected item
    init_pair(3, COLOR_RED, COLOR_BLACK);     // Suspicious process
    init_pair(4, COLOR_GREEN, COLOR_BLACK);   // Normal process
    
    // Create windows
    g_state.main_win = newwin(MAIN_WIN_HEIGHT, MAIN_WIN_WIDTH, 
                             (LINES - MAIN_WIN_HEIGHT) / 2, 
                             (COLS - MAIN_WIN_WIDTH) / 2);
    box(g_state.main_win, 0, 0);
    
    g_state.header_win = derwin(g_state.main_win, 3, MAIN_WIN_WIDTH - 2, 1, 1);
    g_state.list_win = derwin(g_state.main_win, LIST_WIN_HEIGHT, 
                             MAIN_WIN_WIDTH - 2, 4, 1);
    g_state.status_win = derwin(g_state.main_win, STATUS_HEIGHT, 
                               MAIN_WIN_WIDTH - 2, 
                               MAIN_WIN_HEIGHT - STATUS_HEIGHT - 1, 1);
    
    // Initialize state
    g_state.current_index = 0;
    g_state.scroll_position = 0;
    g_state.all_processes = NULL;
    g_state.process_count = 0;
    g_state.suspicious_indices = NULL;
    g_state.suspicious_count = 0;
}

void scan_processes(UIState *state) {
    // Run the process scanner
    start();
    
    // Store all processes
    state->process_count = process_count;
    state->all_processes = malloc(process_count * sizeof(ProcessInfo));
    memcpy(state->all_processes, process_info_array, process_count * sizeof(ProcessInfo));
    
    // Allocate space for suspicious process indices
    state->suspicious_indices = malloc(process_count * sizeof(int));
    state->suspicious_count = 0;
    
    // Check each process against the malware database
    const char *db_file = "full_sorted_file.csv";
    MalwareInfo mal_info;
    
    for (size_t i = 0; i < state->process_count; i++) {
        ProcessInfo *proc = &state->all_processes[i];
        if (strcmp(proc->sha256_hash, "N/A") != 0) {
            if (binary_search_hash(proc->sha256_hash, db_file, &mal_info) > 0) {
                state->suspicious_indices[state->suspicious_count++] = i;
            }
        }
    }
}

void draw_process_list(UIState *state) {
    werase(state->list_win);
    int width = getmaxx(state->list_win);
    int height = getmaxy(state->list_win);
    
    for (int i = 0; i < height && i + state->scroll_position < state->process_count; i++) {
        ProcessInfo *proc = &state->all_processes[i + state->scroll_position];
        
        // Check if process is suspicious
        bool is_suspicious = false;
        for (int j = 0; j < state->suspicious_count; j++) {
            if (state->suspicious_indices[j] == i + state->scroll_position) {
                is_suspicious = true;
                break;
            }
        }
        
        // Highlight selected row
        if (i + state->scroll_position == state->current_index) {
            wattron(state->list_win, COLOR_PAIR(2));
        }
        
        // Set color based on risk level
        if (is_suspicious) {
            wattron(state->list_win, COLOR_PAIR(3));
        } else {
            wattron(state->list_win, COLOR_PAIR(4));
        }
        
        // Print process information
        mvwprintw(state->list_win, i, 0, "%-6d %-20.20s %-20s %-10s",
                  proc->pid,
                  proc->name,
                  process_state(proc->state),
                  is_suspicious ? "Suspicious" : "Normal");
        
        if (is_suspicious) {
            wattroff(state->list_win, COLOR_PAIR(3));
        } else {
            wattroff(state->list_win, COLOR_PAIR(4));
        }
        
        if (i + state->scroll_position == state->current_index) {
            wattroff(state->list_win, COLOR_PAIR(2));
        }
    }
    
    wrefresh(state->list_win);
}
void show_status_message(WINDOW *win, const char *message) {
    werase(win);
    wattron(win, COLOR_PAIR(1));
    // Print status message
    mvwprintw(win, 1, 2, "%s", message);
    // Print controls on first line
    mvwprintw(win, 0, 2, "Up/Down Arrow: Navigate | Enter: Details | q: Quit | r: Rescan");
    wattroff(win, COLOR_PAIR(1));
    wrefresh(win);
}

void draw_header(WINDOW *win) {
    int width = getmaxx(win);
    wattron(win, COLOR_PAIR(1));
    
    // Clear header area
    mvwhline(win, 0, 0, ' ', width);
    mvwprintw(win, 0, (width - 20) / 2, " Process Scanner v1 ");
    // Draw horizontal line 
    mvwhline(win, 2, 0, 0, width); 
    

    // Draw column headers
    mvwhline(win, 1, 0, ' ', width);
    mvwprintw(win, 1, 2, "PID");
    mvwprintw(win, 1, 10, "Name");
    mvwprintw(win, 1, 30, "Status");
    mvwprintw(win, 1, 50, "Risk Level");
    
    wattroff(win, COLOR_PAIR(1));
    wrefresh(win);
}

void cleanup_ui(void) {
    // Delete windows in reverse order of creation
    delwin(g_state.status_win);
    delwin(g_state.list_win);
    delwin(g_state.header_win);
    delwin(g_state.main_win);
    endwin();
    
    // Free allocated memory
    if (g_state.all_processes) {
        free(g_state.all_processes);
    }
    if (g_state.suspicious_indices) {
        free(g_state.suspicious_indices);
    }
}

int main() {
    // Initialize UI
    init_ui();
    
    // Initial scan
    show_status_message(g_state.status_win, "Scanning processes...");
    scan_processes(&g_state);
    
    // Main event loop
    draw_header(g_state.header_win);
    draw_process_list(&g_state);
    
    char status_msg[256];
    snprintf(status_msg, sizeof(status_msg), 
             "Scan complete. Found %zu processes, %d suspicious.", 
             g_state.process_count, g_state.suspicious_count);
    show_status_message(g_state.status_win, status_msg);
    
    while (g_running) {
        int ch = getch();
        
        switch (ch) {
            case KEY_UP:
                if (g_state.current_index > 0) {
                    g_state.current_index--;
                    if (g_state.current_index < g_state.scroll_position) {
                        g_state.scroll_position = g_state.current_index;
                    }
                }
                break;
                
            case KEY_DOWN:
                if (g_state.current_index < g_state.process_count - 1) {
                    g_state.current_index++;
                    if (g_state.current_index >= g_state.scroll_position + LIST_WIN_HEIGHT) {
                        g_state.scroll_position = g_state.current_index - LIST_WIN_HEIGHT + 1;
                    }
                }
                break;
                
            case 'r':
            case 'R':
                show_status_message(g_state.status_win, "Rescanning processes...");
                scan_processes(&g_state);
                snprintf(status_msg, sizeof(status_msg), 
                         "Scan complete. Found %zu processes, %d suspicious.", 
                         g_state.process_count, g_state.suspicious_count);
                show_status_message(g_state.status_win, status_msg);
                break;
                
            case 'q':
            case 'Q':
                g_running = false;
                break;
        }
        
        draw_process_list(&g_state);
        wrefresh(g_state.main_win);
    }
    
    // Cleanup
    free(g_state.all_processes);
    free(g_state.suspicious_indices);
    cleanup_ui();
    
    return 0;
}