#include "processes.h"

ProcessInfo *process_info_array = NULL;
size_t process_count = 0;

const char* process_state(char state) {
    switch (state) {
        case 'R': return "Running";
        case 'S': return "Sleeping";
        case 'D': return "Disk Sleep";
        case 'Z': return "Zombie";
        case 'T': return "Stopped";
        case 't': return "Tracing";
        case 'X': return "Dead";
        default: return "Unknown";
    }
}

// Helper function to read process status
int read_proc_status(int pid, ProcessInfo *info) {
    char path[PATH_MAX];
    char line[MAX_LINE];
    snprintf(path, sizeof(path), "/proc/%d/status", pid);
    
    FILE *f = fopen(path, "r");
    if (!f) return 0;
    
    while (fgets(line, sizeof(line), f)) {
        if (strncmp(line, "Name:", 5) == 0) {
            sscanf(line, "Name: %255s", info->name);
        } else if (strncmp(line, "State:", 6) == 0) {
            sscanf(line, "State: %c", &info->state);
        } else if (strncmp(line, "VmRSS:", 6) == 0) {
            sscanf(line, "VmRSS: %lu", &info->rss);
        }
    }
    fclose(f);
    return 1;
}

// Helper function to read process stat
int read_proc_stat(int pid, ProcessInfo *info) {
    char path[PATH_MAX];
    char line[MAX_LINE];
    snprintf(path, sizeof(path), "/proc/%d/stat", pid);
    
    FILE *f = fopen(path, "r");
    if (!f) return 0;
    
    if (fgets(line, sizeof(line), f)) {
        char *p = strrchr(line, ')');
        if (p) {
            sscanf(p + 2, "%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %lu %lu",
                   &info->utime, &info->stime);
        }
    }
    fclose(f);
    return 1;
}

void compute_sha256(const char *file_path, unsigned char *output_hash) {
    FILE *file = fopen(file_path, "rb");
    if (!file) {
        return;
    }

    SHA256_CTX sha256_ctx;
    SHA256_Init(&sha256_ctx);

    unsigned char buffer[1024];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        SHA256_Update(&sha256_ctx, buffer, bytes_read);
    }

    SHA256_Final(output_hash, &sha256_ctx);
    fclose(file);
}

void hash_to_hex_string(unsigned char *hash, char *output_string) {
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(output_string + (i * 2), "%02x", hash[i]);
    }
    output_string[SHA256_DIGEST_LENGTH * 2] = '\0';
}

void compute_fuzzy_hash(const char *file_path, char *output_hash) {
    char command[1024];
    snprintf(command, sizeof(command), "ssdeep \"%s\" 2>/dev/null", file_path);
    FILE *fp = popen(command, "r");
    if (!fp) {
        strcpy(output_hash, "N/A");
        return;
    }

    char line[1024];
    if (fgets(line, sizeof(line), fp) == NULL) {
        strcpy(output_hash, "N/A");
        pclose(fp);
        return;
    }

    if (fgets(line, sizeof(line), fp) != NULL) {
        char *token = strtok(line, ",");
        if (token) {
            strncpy(output_hash, token, MAX_HASH_LEN - 1);
            output_hash[MAX_HASH_LEN - 1] = '\0';
        } else {
            strcpy(output_hash, "N/A");
        }
    } else {
        strcpy(output_hash, "N/A");
    }
    pclose(fp);
}

int start() {
    DIR *proc_dir;
    struct dirent *entry;
    size_t count = 0;
    
    // First, count processes
    proc_dir = opendir("/proc");
    if (!proc_dir) return 1;
    
    while ((entry = readdir(proc_dir)) != NULL) {
        if (isdigit(entry->d_name[0])) {
            count++;
        }
    }
    closedir(proc_dir);
    
    // Allocate memory for process array
    process_info_array = (ProcessInfo *)malloc(count * sizeof(ProcessInfo));
    if (!process_info_array) return 1;
    
    // Now collect process information
    proc_dir = opendir("/proc");
    if (!proc_dir) {
        free(process_info_array);
        return 1;
    }
    
    process_count = 0;
    while ((entry = readdir(proc_dir)) != NULL && process_count < count) {
        if (!isdigit(entry->d_name[0])) continue;
        
        int pid = atoi(entry->d_name);
        ProcessInfo *info = &process_info_array[process_count];
        memset(info, 0, sizeof(ProcessInfo));
        
        info->pid = pid;
        if (!read_proc_status(pid, info) || !read_proc_stat(pid, info)) {
            continue;
        }
        
        // Get executable path and compute hashes
        char exe_path[PATH_MAX];
        snprintf(exe_path, sizeof(exe_path), "/proc/%d/exe", pid);
        
        if (access(exe_path, R_OK) == 0) {
            char real_path[PATH_MAX];
            if (realpath(exe_path, real_path) != NULL) {
                unsigned char sha256_hash[SHA256_DIGEST_LENGTH];
                compute_sha256(real_path, sha256_hash);
                hash_to_hex_string(sha256_hash, info->sha256_hash);
                compute_fuzzy_hash(real_path, info->fuzzy_hash);
            } else {
                strcpy(info->sha256_hash, "N/A");
                strcpy(info->fuzzy_hash, "N/A");
            }
        } else {
            strcpy(info->sha256_hash, "N/A");
            strcpy(info->fuzzy_hash, "N/A");
        }
        
        process_count++;
    }
    
    closedir(proc_dir);
    printf("Collected information for %zu processes.\n", process_count);
    return 0;
}