#include "processes.h"
#include <ctype.h>

#define MAX_LINE_LENGTH 4096  // Increased for larger entries
#define MAX_HASH_LENGTH 65    // SHA256 hash is 64 chars + null terminator

typedef struct {
    char hash[MAX_HASH_LENGTH];
    char file_name[256];
    char file_type_guess[128];
    char mime_type[128];
    char signature[256];
} MalwareInfo;

// Function to clean string (remove quotes and spaces)
void clean_string(char *str) {
    char *src = str, *dst = str;
    while (*src) {
        if (*src != '"' && (*src != ' ' || dst > str)) {
            *dst++ = *src;
        }
        src++;
    }
    *dst = '\0';
    // Remove trailing spaces
    while (dst > str && isspace(*(dst-1))) {
        *--dst = '\0';
    }
}

// Binary search implementation for large files
int binary_search_hash(const char *target_hash, const char *filename, MalwareInfo *info) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Error opening malware database");
        return -1;
    }

    // Get file size
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    rewind(file);

    // Skip header
    char buffer[MAX_LINE_LENGTH];
    fgets(buffer, sizeof(buffer), file);

    long left = ftell(file);
    long right = file_size;
    
    while (left < right) {
        long mid = left + (right - left) / 2;
        fseek(file, mid, SEEK_SET);
        
        // Read rest of the current line if we're in the middle
        if (mid > 0) {
            fgets(buffer, sizeof(buffer), file);
        }

        // Read the actual line we want to compare
        if (!fgets(buffer, sizeof(buffer), file)) {
            break;
        }

        // Parse the line
        char *hash = strtok(buffer, ",");
        if (!hash) continue;

        clean_string(hash);
        
        int cmp = strcasecmp(hash, target_hash);
        
        if (cmp == 0) {
            // Match found, populate MalwareInfo structure
            strncpy(info->hash, hash, sizeof(info->hash) - 1);
            
            char *token = strtok(NULL, ",");
            if (token) {
                clean_string(token);
                strncpy(info->file_name, token, sizeof(info->file_name) - 1);
            }
            
            token = strtok(NULL, ",");
            if (token) {
                clean_string(token);
                strncpy(info->file_type_guess, token, sizeof(info->file_type_guess) - 1);
            }
            
            token = strtok(NULL, ",");
            if (token) {
                clean_string(token);
                strncpy(info->mime_type, token, sizeof(info->mime_type) - 1);
            }
            
            token = strtok(NULL, ",");
            if (token) {
                clean_string(token);
                strncpy(info->signature, token, sizeof(info->signature) - 1);
            }
            
            fclose(file);
            return 1;
        }
        
        if (cmp < 0) {
            left = ftell(file);
        } else {
            right = mid;
        }
    }

    fclose(file);
    return 0;
}

void* check_process_hashes(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    const char *db_file = "full_sorted_file.csv";  // Updated filename
    MalwareInfo mal_info;
    int suspicious_count = 0;

    printf("Thread %d: Checking processes %d to %d\n", 
           data->thread_id, data->start_index, data->end_index - 1);

    for (int i = data->start_index; i < data->end_index; i++) {
        ProcessInfo *proc = &process_info_array[i];
        
        if (strcmp(proc->sha256_hash, "N/A") != 0) {
            if (binary_search_hash(proc->sha256_hash, db_file, &mal_info) > 0) {
                suspicious_count++;
                printf("\n[!] SUSPICIOUS PROCESS DETECTED [!]\n");
                printf("Process ID: %d\n", proc->pid);
                printf("Process Name: %s\n", proc->name);
                printf("File Name in Database: %s\n", mal_info.file_name);
                printf("File Type: %s\n", mal_info.file_type_guess);
                printf("MIME Type: %s\n", mal_info.mime_type);
                printf("Signature: %s\n", mal_info.signature);
                printf("SHA256: %s\n", mal_info.hash);
                printf("----------------------------------------\n");
            }
        }
    }

    printf("Thread %d completed: Found %d suspicious processes\n", 
           data->thread_id, suspicious_count);
    
    return NULL;
}

int main() {
    printf("Starting process scanner...\n");
    
    // Initialize process collection
    if (start() != 0) {
        printf("Error collecting process information\n");
        return 1;
    }

    printf("Collected information for %zu processes\n", process_count);
    printf("Starting hash comparison with multiple threads...\n");

    // Determine optimal thread count based on CPU cores
    int num_threads = sysconf(_SC_NPROCESSORS_ONLN);
    if (num_threads <= 0) num_threads = 4;  // Fallback to 4 if detection fails
    
    printf("Using %d threads for hash comparison\n", num_threads);

    pthread_t *threads = malloc(num_threads * sizeof(pthread_t));
    ThreadData *thread_data = malloc(num_threads * sizeof(ThreadData));

    if (!threads || !thread_data) {
        printf("Memory allocation failed\n");
        free(process_info_array);
        return 1;
    }

    // Calculate work distribution
    int processes_per_thread = process_count / num_threads;
    int remaining = process_count % num_threads;
    int start_index = 0;

    // Create threads
    for (int i = 0; i < num_threads; i++) {
        thread_data[i].start_index = start_index;
        thread_data[i].end_index = start_index + processes_per_thread + (i < remaining ? 1 : 0);
        thread_data[i].thread_id = i;

        if (pthread_create(&threads[i], NULL, check_process_hashes, &thread_data[i]) != 0) {
            printf("Failed to create thread %d\n", i);
            free(threads);
            free(thread_data);
            free(process_info_array);
            return 1;
        }

        start_index = thread_data[i].end_index;
    }

    // Wait for threads to complete
    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("\nProcess scan completed.\n");

    // Cleanup
    free(threads);
    free(thread_data);
    free(process_info_array);
    return 0;
}