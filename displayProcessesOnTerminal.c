#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include <unistd.h>
#include <sys/proc_info.h>
#include <mach/mach.h>
#include <libproc.h>
#include <openssl/sha.h>
#include <termios.h>
#include <fcntl.h>

#define MAX_PROC 1024

const char* process_state(int state) {
    switch (state) {
        case SIDL: return "Idle";
        case SRUN: return "Running";
        case SSLEEP: return "Sleeping";
        case SSTOP: return "Stopped";
        default: return "Unknown";
    }
}

void compute_sha256(const char *file_path, unsigned char *output_hash) {
    FILE *file = fopen(file_path, "rb");
    if (!file) {
        perror("Unable to open file for SHA-256 computation");
        return;
    }

    SHA256_CTX sha256_ctx;
    SHA256_Init(&sha256_ctx);

    unsigned char buffer[1024];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), file)) > 0) {
        SHA256_Update(&sha256_ctx, buffer, bytes_read);
    }

    SHA256_Final(output_hash, &sha256_ctx);
    fclose(file);
}

void hash_to_hex_string(unsigned char *hash, char *output_string) {
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(output_string + (i * 2), "%02x", hash[i]);
    }
    output_string[SHA256_DIGEST_LENGTH * 2] = '\0';
}

int kbhit(void) {
    struct termios oldt, newt;
    int ch;
    int oldf;

    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);

    ch = getchar();

    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    fcntl(STDIN_FILENO, F_SETFL, oldf);

    if (ch != EOF) {
        ungetc(ch, stdin);
        return 1;
    }

    return 0;
}

int main() {
    int mib[4];
    size_t len;
    struct kinfo_proc *procs;
    int count;

    mib[0] = CTL_KERN;
    mib[1] = KERN_PROC;
    mib[2] = KERN_PROC_ALL;
    mib[3] = 0;

    // Print the header once
    printf("PID\tProcess Name\tState\tCPU Time (user+system)\tRSS Size\tSHA-256 Hash\n");
    printf("----------------------------------------------------------------------------------\n");

    while (!kbhit()) {
        sysctl(mib, 4, NULL, &len, NULL, 0);
        procs = (struct kinfo_proc*)malloc(len);
        sysctl(mib, 4, procs, &len, NULL, 0);

        count = len / sizeof(struct kinfo_proc);

        // Move cursor to the beginning of the process list display area
        printf("\033[2;0H");  // ANSI escape code to move the cursor to row 2, column 0

        for (int i = 0; i < count; i++) {
            pid_t pid = procs[i].kp_proc.p_pid;
            char name[256];
            strncpy(name, procs[i].kp_proc.p_comm, sizeof(name));

            struct proc_taskinfo pti;
            size_t pti_len = sizeof(pti);
            if (proc_pidinfo(pid, PROC_PIDTASKINFO, 0, &pti, pti_len) != -1) {
                unsigned long long total_cpu_time = pti.pti_total_user + pti.pti_total_system;
                unsigned long long rss_size = pti.pti_resident_size;
                int state = procs[i].kp_proc.p_stat;

                char exe_path[1024];
                ssize_t path_len = proc_pidpath(pid, exe_path, sizeof(exe_path));

                char sha256_hash_str[SHA256_DIGEST_LENGTH * 2 + 1];
                if (path_len > 0) {
                    unsigned char sha256_hash[SHA256_DIGEST_LENGTH];
                    compute_sha256(exe_path, sha256_hash);
                    hash_to_hex_string(sha256_hash, sha256_hash_str);
                } else {
                    strcpy(sha256_hash_str, "N/A");
                }

                // Print or update each line with process information
                printf("%d\t%s\t%s\t%llu\t%llu\t%s\n", 
                        pid, 
                        name, 
                        process_state(state), 
                        total_cpu_time, 
                        rss_size, 
                        sha256_hash_str);
            }
        }

        free(procs);

        printf("Press Enter to stop...\n");

        usleep(1000000); // Sleep for 1 second
    }

    // Consume the Enter key press to exit
    getchar();
    printf("Process information display terminated.\n");
    return 0;
}
